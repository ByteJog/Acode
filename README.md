# 第二章 操作系统组织

对操作系统的一个关键要求是同时支持多个活动。例如，使用第1章中描述的系统调用接口，一个进程可以用fork启动新的进程。操作系统必须在这些进程中分时使用计算机资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须确保所有的进程都有机会执行。操作系统还必须安排进程间的隔离。也就是说，如果一个进程有一个bug并出现故障，它不应该影响那些不依赖于有bug的进程的进程。然而，完全隔离并不可行，因为进程有可能有意地相互作用；管道就是一个例子。因此，操作系统必须满足三个要求:多路复用、隔离和交互。

本章概述了如何组织操作系统来实现这三个要求。事实证明，有许多方法可以做到这一点，但是本文主要关注的是以单片内核为中心的主流设计，许多Unix操作系统都使用这种内核。本章还概述了xv6进程（xv6中的隔离单元）以及xv6启动时第一个进程的创建。

Xv6运行在多核RISC-V微处理器，它的许多低级功能(例如，它的进程实现)是RISC-V特有的。RISC-V是64位CPU，xv6是用“LP64”C编写的，这意味着C编程语言中的long (L)和pointers (P)是64位，但int是32位。

在一台完整的计算机中，CPU被一系列硬件所包围，其中大部分是I/O接口。Xv6支持的硬件环境为qemu模拟的“-machine virt”。该模拟环境包括RAM、包含引导代码的ROM、到用户键盘/屏幕的串行连接以及用于存储的磁盘。

## 2.1 抽象物理资源
当遇到一个操作系统时，人们可能会问的第一个问题是为什么要有它？也就是说，可以实现图1.2中的系统调用作为应用程序链接的库。在这个计划中，每个应用程序甚至可以根据自己的需要定制自己的库。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源(例如，实现高性能或可预测的性能)。一些用于嵌入式设备或实时系统的操作系统就是这样组织的。

这种库方法的缺点是，如果有多个应用程序在运行，这些应用程序必须表现良好。例如，每个应用程序必须定期放弃CPU，以便其他应用程序可以运行。如果所有的应用程序都相互信任并且没有错误，这样的协作式分时方案可能是可以的。对于应用程序来说，相互不信任和存在错误更为常见，因此人们通常希望比合作方案提供的隔离更强。为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而是将资源抽象为服务是很有帮助的。例如，Unix应用程序只能通过文件系统的open、read、write和close系统调用与存储交互，而不能直接读写磁盘。这为应用程序提供了路径名的便利，并允许操作系统(作为接口的实现者)管理磁盘。即使隔离不是一个问题，有意交互的程序(或者只是希望避开彼此的方式)很可能会发现文件系统是一个更方便的抽象而不是直接使用磁盘。

类似地，Unix透明地在进程间切换硬件CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道时间共享。这种透明性允许操作系统共享CPU，即使有些应用程序处于无限循环中。

作为另一个例子，Unix进程使用exec来构建它们的内存映像，而不是直接与物理内存交互。这允许操作系统决定在内存中的什么地方放置一个进程；如果内存紧张，操作系统甚至可能将进程的一些数据存储在磁盘上。Exec还为用户提供了方便的文件系统来存储可执行程序映像。

Unix进程之间许多形式的交互都是通过文件描述符进行的。文件描述符不仅抽象出许多细节(例如，管道或文件中的数据存储在哪里)，还以简化交互的方式定义它们。例如，如果管道中的一个应用程序失败，内核会为管道中的下一个进程生成一个文件结束信号。 图1.2中的系统调用界面经过精心设计，为程序员提供了便利，同时也提供了高度隔离的可能性。Unix接口不是抽象资源的唯一方式，但它被证明是一种非常好的方式。

## 2.2 用户模式、管理员模式和系统调用
强隔离要求应用程序和操作系统之间有一个硬边界。如果应用程序出错，我们不希望操作系统失败或其他应用程序失败。相反，操作系统应该能够清理失败的应用程序，并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改(甚至不能读取)操作系统的数据结构和指令，并且应用程序不能访问其他进程的内存。

CPU为强隔离提供硬件支持。例如，RISC-V有三种CPU可以执行指令的模式:机器模式、管理模式和用户模式。在机器模式下执行的指令具有完全特权；CPU以机器模式启动。机器模式主要用于配置计算机。Xv6在机器模式下执行几行代码，然后切换到管理员模式。 在管理模式下，CPU被允许执行特权指令:例如，启用和禁用中断，读写保存页表地址的寄存器等。如果用户模式下的应用程序试图执行特权指令，那么CPU不会执行该指令，而是切换到管理模式，以便管理模式代码可以终止该应用程序，因为它做了不该做的事情。在第1章的图1.1中说明了这中组织方式。应用程序只能执行用户模式指令(例如，添加数字等)。)并被称为运行在用户空间，而管理模式下的软件也可以执行特权指令，并被称为运行在内核空间。运行在内核空间(或管理模式)的软件称为内核。

想要调用内核函数(例如xv6中的read系统调用)的应用程序必须转换到内核；应用程序不能直接调用内核函数。CPU提供了一个特殊的指令，将CPU从用户模式切换到管理模式，并在内核指定的入口点进入内核。(RISC-V为此提供了ecall指令。)一旦CPU切换到管理员模式，内核就可以验证系统调用的参数(例如，检查传递给系统调用的地址是否是应用程序存储器的一部分)，决定是否允许应用程序执行所请求的操作(例如，检查是否允许应用程序写入指定的文件)，然后拒绝或执行该操作。内核控制转换到管理模式的入口点是很重要的；例如，如果应用程序可以决定内核入口点，恶意应用程序就可以在跳过参数验证的地方进入内核。

## 2.3 核心组织
一个关键的设计问题是操作系统的哪一部分应该在管理模式下运行。一种可能是，整个操作系统都驻留在内核中，因此所有系统调用的实现都在管理模式下运行。这种组织被称为宏内核。

在这个组织中，整个操作系统以完全的硬件特权运行。这种组织很方便，因为OS设计者不必决定操作系统的哪一部分不需要完全的硬件特权。此外，操作系统的不同部分更容易协作。例如，一个操作系统可能有一个可以由文件系统和虚拟内存系统共享的缓冲区缓存。 单一组织的一个缺点是操作系统不同部分之间的接口通常很复杂(正如我们将在本文的其余部分看到的那样)，因此也确实如此

图2.1:带有文件系统服务器的微内核

操作系统开发人员很容易犯错误。在单片内核中，错误是致命的，因为管理模式中的错误通常会导致内核失败。如果内核失败，计算机停止工作，因此所有应用程序也会失败。计算机必须重新启动才能再次启动。 为了降低内核出错的风险，操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。这种内核组织被称为微内核。

数字2.1 展示了这种微内核设计。在图中，文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一种进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送一条消息，并等待响应。

在微内核中，内核接口由一些低级功能组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。

在现实世界中，单片内核和微内核都很受欢迎。许多Unix内核都是单片的。例如，Linux具有单片内核，尽管一些OS功能作为用户级服务器运行(例如，窗口系统)。Linux为操作系统密集型应用程序提供了高性能，部分原因是内核的子系统可以紧密集成。

Minix、L4和QNX等操作系统被组织成一个带有服务器的微内核，并在嵌入式环境中得到了广泛的部署。L4的一个变体seL4足够小，已经过内存安全和其他安全属性的验证[7].

在操作系统的开发者中，对于哪种组织更好有很多争论，并且没有这样或那样的决定性证据。此外，这在很大程度上取决于“更好”的含义:更快的性能、更小的代码大小、内核的可靠性、整个操作系统的可靠性(包括用户级服务)等等。

还有比哪个组织的问题更重要的实际考虑。一些操作系统有一个微内核，但是由于性能原因，在内核空间中运行一些用户级服务。一些操作系统具有单片内核，因为这是它们开始的方式，并且没有什么动力转向纯微内核组织，因为新特性可能比重写现有操作系统以适应微内核设计更重要。

从这本书的角度来看，微内核和单片操作系统有许多共同的关键思想。它们实现系统调用，使用页表，处理中断，支持进程，它们使用锁进行并发控制，它们实现文件系统，等等。这本书关注这些核心思想。 像大多数Unix操作系统一样，Xv6是作为一个整体内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现完整的操作系统。由于xv6没有提供很多服务，所以它的内核比一些微内核要小，但是从概念上来说，xv6是单片的。